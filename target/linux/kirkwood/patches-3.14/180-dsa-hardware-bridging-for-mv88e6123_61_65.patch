From a90541923d90c6ce99b7139416a24b1942873c1f Mon Sep 17 00:00:00 2001
From: Eugene Sanivsky <seugene@marvell.com>
Date: Thu, 7 Aug 2014 14:10:40 +0300
Subject: [PATCH] dsa: hardware bridging for mv88e6123_61_65

---
 drivers/net/dsa/mv88e6123_61_65.c | 172 +++++++++++++++++++++++++++++++++++++-
 drivers/net/dsa/mv88e6xxx.h       |  12 +++
 include/linux/netdevice.h         |   6 ++
 include/net/dsa.h                 |   9 ++
 net/bridge/br_if.c                |   6 ++
 net/bridge/br_stp.c               |   3 +
 net/dsa/slave.c                   |  35 ++++++++
 7 files changed, 240 insertions(+), 3 deletions(-)

diff --git a/drivers/net/dsa/mv88e6123_61_65.c b/drivers/net/dsa/mv88e6123_61_65.c
index 41ee5b6..be546be 100644
--- a/drivers/net/dsa/mv88e6123_61_65.c
+++ b/drivers/net/dsa/mv88e6123_61_65.c
@@ -14,6 +14,7 @@
 #include <linux/module.h>
 #include <linux/netdevice.h>
 #include <linux/phy.h>
+#include <linux/if_bridge.h>
 #include <net/dsa.h>
 #include "mv88e6xxx.h"
 
@@ -218,10 +219,10 @@ static int mv88e6123_61_65_setup_port(struct dsa_switch *ds, int p)
 		val |= 0x000c;
 	REG_WRITE(addr, 0x04, val);
 
-	/* Port Control 1: disable trunking.  Also, if this is the
-	 * CPU port, enable learn messages to be sent to this port.
+	/*
+	 * Port Control 1: disable trunking.
 	 */
-	REG_WRITE(addr, 0x05, dsa_is_cpu_port(ds, p) ? 0x8000 : 0x0000);
+	REG_WRITE(addr, 0x05, 0x0000);
 
 	/* Port based VLAN map: give each port its own address
 	 * database, allow the CPU port to talk to each of the 'real'
@@ -287,6 +288,8 @@ static int mv88e6123_61_65_setup_port(struct dsa_switch *ds, int p)
 	return 0;
 }
 
+static void mv88e6123_61_65_hw_bridge_sync_work(struct work_struct *ugly);
+
 static int mv88e6123_61_65_setup(struct dsa_switch *ds)
 {
 	struct mv88e6xxx_priv_state *ps = (void *)(ds + 1);
@@ -296,6 +299,9 @@ static int mv88e6123_61_65_setup(struct dsa_switch *ds)
 	mutex_init(&ps->smi_mutex);
 	mutex_init(&ps->stats_mutex);
 
+	spin_lock_init(&ps->hw_bridge_state);
+	INIT_WORK(&ps->hw_bridge_work, mv88e6123_61_65_hw_bridge_sync_work);
+
 	ret = mv88e6123_61_65_switch_reset(ds);
 	if (ret < 0)
 		return ret;
@@ -310,11 +316,168 @@ static int mv88e6123_61_65_setup(struct dsa_switch *ds)
 		ret = mv88e6123_61_65_setup_port(ds, i);
 		if (ret < 0)
 			return ret;
+
+		// @@@
+		ps->fid[i] = i;
+		ps->stp_state[i] = 3;
 	}
 
 	return 0;
 }
 
+static void mv88e6123_61_65_hw_bridge_sync_work(struct work_struct *ugly)
+{
+	struct mv88e6xxx_priv_state *ps;
+	struct dsa_switch *ds;
+	int i;
+
+	ps = container_of(ugly, struct mv88e6xxx_priv_state, hw_bridge_work);
+	ds = ((struct dsa_switch *)ps) - 1;
+
+	spin_lock(&ps->hw_bridge_state);
+	for (i = 0; i < MV88E6XXX_MAX_PORTS; i++) {
+		if (ps->fid_dirty[i]) {
+			int reg;
+			int j;
+
+			reg = (ps->fid[i] << 12) | (1 << ds->dst->cpu_port);
+			ps->fid_dirty[i] = 0;
+
+			for (j = 0; j < MV88E6XXX_MAX_PORTS; j++) {
+				if (i != j && ps->bridge[i] != NULL &&
+				    ps->bridge[i] == ps->bridge[j]) {
+					reg |= 1 << j;
+				}
+			}
+
+			spin_unlock(&ps->hw_bridge_state);
+			mv88e6xxx_reg_write(ds, REG_PORT(i), 6, reg);
+			spin_lock(&ps->hw_bridge_state);
+		}
+
+		if (ps->stp_state_dirty[i]) {
+			int new_state;
+			int reg;
+
+			new_state = ps->stp_state[i];
+			ps->stp_state_dirty[i] = 0;
+			spin_unlock(&ps->hw_bridge_state);
+			reg = mv88e6xxx_reg_read(ds, REG_PORT(i), 4);
+			if (reg >= 0) {
+				reg &= ~0x0003;
+				reg |= new_state;
+				mv88e6xxx_reg_write(ds, REG_PORT(i), 4, reg);
+			}
+			spin_lock(&ps->hw_bridge_state);
+		}
+	}
+	spin_unlock(&ps->hw_bridge_state);
+}
+
+static void
+set_stp_state(struct dsa_switch *ds, int port, int state)
+{
+	struct mv88e6xxx_priv_state *ps = (void *)(ds + 1);
+	int hw_state = 0;
+
+	switch (state) {
+	case BR_STATE_DISABLED:
+		hw_state = 0;
+		break;
+	case BR_STATE_BLOCKING:
+	case BR_STATE_LISTENING:
+		hw_state = 1;
+		break;
+	case BR_STATE_LEARNING:
+		hw_state = 2;
+		break;
+	case BR_STATE_FORWARDING:
+		hw_state = 3;
+		break;
+	default:
+		BUG();
+	}
+
+	if (ps->stp_state[port] != hw_state) {
+		ps->stp_state_dirty[port] = 1;
+		ps->stp_state[port] = hw_state;
+	}
+}
+
+static void
+mv88e6123_61_65_bridge_join(struct dsa_switch *ds, int port, void *bridge)
+{
+	struct mv88e6xxx_priv_state *ps = (void *)(ds + 1);
+	int fid;
+	int i;
+
+	spin_lock(&ps->hw_bridge_state);
+
+	fid = 65536;
+	for (i = 0; i < MV88E6XXX_MAX_PORTS; i++) {
+		if (ps->bridge[i] == bridge) {
+			if (ps->fid[i] < fid)
+				fid = ps->fid[i];
+			ps->fid_dirty[i] = 1;
+		}
+	}
+
+	ps->bridge[port] = bridge;
+
+	ps->fid_dirty[port] = 1;
+	if (fid != 65536)
+		ps->fid[port] = fid;
+
+	set_stp_state(ds, port, BR_STATE_DISABLED);
+
+	spin_unlock(&ps->hw_bridge_state);
+
+	schedule_work(&ps->hw_bridge_work);
+}
+
+static void
+mv88e6123_61_65_bridge_set_stp_state(struct dsa_switch *ds, int port, int state)
+{
+	struct mv88e6xxx_priv_state *ps = (void *)(ds + 1);
+
+	spin_lock(&ps->hw_bridge_state);
+	set_stp_state(ds, port, state);
+	spin_unlock(&ps->hw_bridge_state);
+
+	schedule_work(&ps->hw_bridge_work);
+}
+
+static void mv88e6123_61_65_bridge_leave(struct dsa_switch *ds, int port)
+{
+	struct mv88e6xxx_priv_state *ps = (void *)(ds + 1);
+	u16 free_fids;
+	int i;
+	int fid;
+
+	spin_lock(&ps->hw_bridge_state);
+
+	free_fids = 0xffff;
+	for (i = 0; i < MV88E6XXX_MAX_PORTS; i++) {
+		if (dsa_is_cpu_port(ds, i) || ds->dsa_port_mask & (1 << i)) {
+			if (ps->bridge[i] == ps->bridge[port])
+				ps->fid_dirty[i] = 1;
+			if (i != port)
+				free_fids &= ~(1 << ps->fid[i]);
+		}
+	}
+
+	fid = ffs(free_fids) - 1;
+
+	ps->fid[port] = fid;
+	ps->bridge[port] = NULL;
+
+	set_stp_state(ds, port, BR_STATE_FORWARDING);
+
+	spin_unlock(&ps->hw_bridge_state);
+
+	schedule_work(&ps->hw_bridge_work);
+}
+
 static int mv88e6123_61_65_port_to_phy_addr(int port)
 {
 	if (port >= 0 && port <= 4)
@@ -402,6 +565,9 @@ struct dsa_switch_driver mv88e6123_61_65_switch_driver = {
 	.get_strings		= mv88e6123_61_65_get_strings,
 	.get_ethtool_stats	= mv88e6123_61_65_get_ethtool_stats,
 	.get_sset_count		= mv88e6123_61_65_get_sset_count,
+	.bridge_join		= mv88e6123_61_65_bridge_join,
+	.bridge_set_stp_state	= mv88e6123_61_65_bridge_set_stp_state,
+	.bridge_leave		= mv88e6123_61_65_bridge_leave,
 };
 
 MODULE_ALIAS("platform:mv88e6123");
diff --git a/drivers/net/dsa/mv88e6xxx.h b/drivers/net/dsa/mv88e6xxx.h
index 911ede5..91eb2c6 100644
--- a/drivers/net/dsa/mv88e6xxx.h
+++ b/drivers/net/dsa/mv88e6xxx.h
@@ -14,6 +14,7 @@
 #define REG_PORT(p)		(0x10 + (p))
 #define REG_GLOBAL		0x1b
 #define REG_GLOBAL2		0x1c
+#define MV88E6XXX_MAX_PORTS	11
 
 struct mv88e6xxx_priv_state {
 	/* When using multi-chip addressing, this mutex protects
@@ -37,6 +38,17 @@ struct mv88e6xxx_priv_state {
 	 */
 	struct mutex	stats_mutex;
 
+	/*
+	 * Hardware bridging state.
+	 */
+	spinlock_t	hw_bridge_state;
+	struct work_struct	hw_bridge_work;
+	void		*bridge[MV88E6XXX_MAX_PORTS];
+	int		fid_dirty[MV88E6XXX_MAX_PORTS];
+	int		fid[MV88E6XXX_MAX_PORTS];
+	int		stp_state_dirty[MV88E6XXX_MAX_PORTS];
+	int		stp_state[MV88E6XXX_MAX_PORTS];
+
 	int		id; /* switch product id */
 };
 
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 6151e90..ea47a49 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1126,6 +1126,12 @@ struct net_device_ops {
 						      u32 filter_mask);
 	int			(*ndo_bridge_dellink)(struct net_device *dev,
 						      struct nlmsghdr *nlh);
+	void			(*ndo_bridge_join)(struct net_device *dev,
+						   void *bridge);
+	void			(*ndo_bridge_set_stp_state)(struct net_device *dev,
+							    int state);
+	void			(*ndo_bridge_leave)(struct net_device *dev);
+
 	int			(*ndo_change_carrier)(struct net_device *dev,
 						      bool new_carrier);
 	int			(*ndo_get_phys_port_id)(struct net_device *dev,
diff --git a/include/net/dsa.h b/include/net/dsa.h
index 7828ebf..77e0318 100644
--- a/include/net/dsa.h
+++ b/include/net/dsa.h
@@ -176,6 +176,15 @@ struct dsa_switch_driver {
 	void	(*get_ethtool_stats)(struct dsa_switch *ds,
 				     int port, uint64_t *data);
 	int	(*get_sset_count)(struct dsa_switch *ds);
+
+	/*
+	 * Hardware bridging.
+	 */
+	void	(*bridge_join)(struct dsa_switch *ds, int port,
+		 void *bridge);
+	void	(*bridge_set_stp_state)(struct dsa_switch *ds, int port,
+		 int state);
+	void	(*bridge_leave)(struct dsa_switch *ds, int port);
 };
 
 void register_switch_driver(struct dsa_switch_driver *type);
diff --git a/net/bridge/br_if.c b/net/bridge/br_if.c
index 459dab2..b31c7c0 100644
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -139,6 +139,9 @@ static void del_nbp(struct net_bridge_port *p)
 	br_stp_disable_port(p);
 	spin_unlock_bh(&br->lock);
 
+	if (dev->netdev_ops->ndo_bridge_leave != NULL)
+		dev->netdev_ops->ndo_bridge_leave(dev);
+
 	br_ifinfo_notify(RTM_DELLINK, p);
 
 	nbp_vlan_flush(p);
@@ -405,6 +408,9 @@ int br_add_if(struct net_bridge *br, struct net_device *dev)
 	if (changed_addr)
 		call_netdevice_notifiers(NETDEV_CHANGEADDR, br->dev);
 
+	if (dev->netdev_ops->ndo_bridge_join != NULL)
+	    dev->netdev_ops->ndo_bridge_join(dev, (void *)br);
+
 	dev_set_mtu(br->dev, br_min_mtu(br));
 
 	kobject_uevent(&p->kobj, KOBJ_ADD);
diff --git a/net/bridge/br_stp.c b/net/bridge/br_stp.c
index b01849a..f5620ee 100644
--- a/net/bridge/br_stp.c
+++ b/net/bridge/br_stp.c
@@ -34,6 +34,9 @@ void br_log_state(const struct net_bridge_port *p)
 	br_info(p->br, "port %u(%s) entered %s state\n",
 		(unsigned int) p->port_no, p->dev->name,
 		br_port_state_names[p->state]);
+
+	if (p->dev->netdev_ops->ndo_bridge_set_stp_state != NULL)
+	    p->dev->netdev_ops->ndo_bridge_set_stp_state(p->dev, p->state);
 }
 
 /* called under bridge lock */
diff --git a/net/dsa/slave.c b/net/dsa/slave.c
index 6ebd8fb..cbd7afe 100644
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@ -171,6 +171,32 @@ static int dsa_slave_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	return -EOPNOTSUPP;
 }
 
+static void dsa_bridge_join(struct net_device *dev, void *bridge)
+{
+	struct dsa_slave_priv *p = netdev_priv(dev);
+	struct dsa_switch *ds = p->parent;
+
+	if (ds->drv->bridge_join != NULL)
+		ds->drv->bridge_join(ds, p->port, bridge);
+}
+
+static void dsa_bridge_set_stp_state(struct net_device *dev, int state)
+{
+	struct dsa_slave_priv *p = netdev_priv(dev);
+	struct dsa_switch *ds = p->parent;
+
+	if (ds->drv->bridge_set_stp_state != NULL)
+		ds->drv->bridge_set_stp_state(ds, p->port, state);
+}
+
+static void dsa_bridge_leave(struct net_device *dev)
+{
+	struct dsa_slave_priv *p = netdev_priv(dev);
+	struct dsa_switch *ds = p->parent;
+
+	if (ds->drv->bridge_leave != NULL)
+		ds->drv->bridge_leave(ds, p->port);
+}
 
 /* ethtool operations *******************************************************/
 static int
@@ -303,6 +329,9 @@ static const struct net_device_ops dsa_netdev_ops = {
 	.ndo_set_rx_mode	= dsa_slave_set_rx_mode,
 	.ndo_set_mac_address	= dsa_slave_set_mac_address,
 	.ndo_do_ioctl		= dsa_slave_ioctl,
+	.ndo_bridge_join	= dsa_bridge_join,
+	.ndo_bridge_set_stp_state	= dsa_bridge_set_stp_state,
+	.ndo_bridge_leave	= dsa_bridge_leave,
 };
 #endif
 #ifdef CONFIG_NET_DSA_TAG_EDSA
@@ -315,6 +344,9 @@ static const struct net_device_ops edsa_netdev_ops = {
 	.ndo_set_rx_mode	= dsa_slave_set_rx_mode,
 	.ndo_set_mac_address	= dsa_slave_set_mac_address,
 	.ndo_do_ioctl		= dsa_slave_ioctl,
+	.ndo_bridge_join	= dsa_bridge_join,
+	.ndo_bridge_set_stp_state	= dsa_bridge_set_stp_state,
+	.ndo_bridge_leave	= dsa_bridge_leave,
 };
 #endif
 #ifdef CONFIG_NET_DSA_TAG_TRAILER
@@ -327,6 +359,9 @@ static const struct net_device_ops trailer_netdev_ops = {
 	.ndo_set_rx_mode	= dsa_slave_set_rx_mode,
 	.ndo_set_mac_address	= dsa_slave_set_mac_address,
 	.ndo_do_ioctl		= dsa_slave_ioctl,
+	.ndo_bridge_join	= dsa_bridge_join,
+	.ndo_bridge_set_stp_state	= dsa_bridge_set_stp_state,
+	.ndo_bridge_leave	= dsa_bridge_leave,
 };
 #endif
 
-- 
2.0.4

